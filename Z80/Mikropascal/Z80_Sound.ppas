program Z80_Sound;

(*
 * SID Sound card
 * Clock: 50 MHz ext. = 12.5 MHz int.
 *
 * pin layout:
 * RA0-RA4: SID A0-A4
 * RE3: /RESET
 * RA5: SID /CS
 * RA6: LED
 * RC0-RC7: SID D0-D7
 * RB0-RB7: DATA0-DATA7
 *)

uses
  SoundUtils;

type
  TNoteRec = record
    code: byte; // midi note code
    duration: byte; // 0 = 1/1, 1 = 1/2, 2 = 1/4, 3 = 1/8, 4 = 1/16
  end;

const
  TMR0H_Value = $EC; // values for 25 msec
  TMR0L_Value = $ED;

var
  Sustain: array[3] of byte; // duration of sustain in 20 msec.
  Notes: array[3] of array[icNoteCount] of TNoteRec;
  NoteCounts: array[3] of word;

  curr_stn: array[3] of byte;
  curr_period: array[3] of byte;
  curr_note: array[3] of word;
  play: byte;
  curr_input_voice: byte;
  
(******************************************************************************)
procedure Interrupt;
begin
  // triggered every 25 msec
  TMR0H := TMR0H_Value;
  TMR0L := TMR0L_Value;

  if play = 1 then
  begin
  
  
  
    LATA.6 := 1 - LATA.6;
  end // if play = 1 then
  else
    LATA.6 := 0;

  INTCON.TMR0IF := 0;
end;
(******************************************************************************)
procedure Init;
begin
//  OSCCON := %01120000;

  ADCON0 := 0; // disable A/D Converter
  ADCON1 := $0f;
  CMCON := $07; // disable comparator

  INTCON := %10100000; // Enable Timer0 interrupt
  PIE1 := 0;
  PIE2 := 0;
  RCON := 0;
  CCP1CON := 0;
  SSPCON1 := 0;
  SSPCON2 := 0;
  T0CON := %00000101; // Timer0: prescaler 64, 16 bit, disabled
  TMR0H := TMR0H_Value;
  TMR0L := TMR0L_Value;

  TRISA := 0;
  PORTA := %00100000;
  TRISB := 255;
  PORTB := 0;
  TRISC := 0;
  PORTC := 0;
end;
(******************************************************************************)
procedure InitSID;
begin
  SetVolume($0f);
end;
(******************************************************************************)
function Hex2Byte(ch1, ch2: char): byte;
begin
  if (ch1 >= 'a') and (ch1 <= 'f') then
    Result := (10 + ch1 - 'a') * 16
  else if (ch1 >= '0') and (ch1 <= '9') then
    Result := (ch1 - '0') * 16
  else
    Result := 0;

  if (ch2 >= 'a') and (ch2 <= 'f') then
    Result := Result + 10 + ch2 - 'a'
  else if (ch2 >= '0') and (ch2 <= '9') then
    Result := Result + ch2 - '0';
end;
(******************************************************************************)
procedure ExecuteCommand(var _cmd: string[8]);
var
  c1, c2: char;
  value, i: byte;
  ncount: word;
  note: TNoteRec;
  
begin
  c1 := _cmd[0];
  c2 := _cmd[1];
  
  if (c1 = 'V') and (c2 = 'O') then
  begin
    // VOx - set global volume (x = value)
    SetVolume(Hex2Byte('0', _cmd[2]));
  end
  else if (c1 = 'A') and (c2 = 'D') then
  begin
    // ADvxx - set attack time/decay time (v = voice, xx = value)
    SetAtkDcy(_cmd[2] - '0', Hex2Byte(_cmd[3], _cmd[4]));
  end
  else if (c1 = 'S') and (c2 = 'R') then
  begin
    // SRvxx - set sustain level/release time (v = voice, xx = value)
    SetStnRls(_cmd[2] - '0', Hex2Byte(_cmd[3], _cmd[4]));
  end
  else if (c1 = 'S') and (c2 = 'T') then
  begin
    // STvxx - set sustain duration
    Sustain[_cmd[2] - '0'] := Hex2Byte(_cmd[3], _cmd[4]);
  end
  else if (c1 = 'W') and (c2 = 'F') then
  begin
    // WFvx - set waveform (v = voice, x = waveform: 0 = off, 1 = triangle, 2 = sawtooth, 3 = rectangle, 4 = noise)
    case _cmd[3] of
      '0': value := 0;
      '1': value := icWaveTriangle;
      '2': value := icWaveSawtooth;
      '3': value := icWaveRectangle;
      '4': value := icWaveNoise;
    end;
    SetWaveForm(_cmd[2] - '0', value);
  end
  else if (c1 = 'P') and (c2 = 'W') then
  begin
    // PWvxxx - set rectangle pulse width (v = voice, xxx = value)
    SetPulseWidth(_cmd[2] - '0', Hex2Byte(_cmd[3], _cmd[4]));
  end
  else if (c1 = 'S') and (c2 = 'N') then
  begin
    // SNv - start input of notes (v = voice)
    curr_input_voice := _cmd[2] - '0';
    NoteCounts[curr_input_voice] := 0;
  end
  else if (c1 = 'E') and (c2 = 'N') then
  begin
    // EN - end input of notes

  end
  else if (c1 = 'N') and (c2 = 'O') then
  begin
    // NOnnnd - input note nnn, duration d (0 = 1/1, 1 = 1/2, 2 = 1/4, 3 = 1/8, 4 = 1/16)
    ncount := NoteCounts[curr_input_voice];
    note.code := StrToMidiNote(_cmd[2], _cmd[3], _cmd[4]);
    note.duration := cmd[5] - '0';
    Notes[curr_input_voice][ncount] = note;
    NoteCounts[curr_input_voice] := ncount + 1;
  end
  else if (c1 = 'P') and (c2 = 'L') then
  begin
    // PL - start playing
    for i := 0 to 2 do
    begin
      curr_note[i] := 0;
      curr_stn[i] := 0;
      curr_period[i] := 0;
    end;
    play := 1;
  end
  else if (c1 = 'S') and (c2 = 'T') then
  begin
    // ST - stop playing
    play := 0;
    StopAll;
  end
  else if (c1 = 'L') and (c2 = 'D') then
  begin
    // LDx - LED, x: 1 = on, 0 = off
    if _cmd[2] = '0' then
      LATA.6 := 0
    else
      LATA.6 := 1;
  end
  else if (c1 = 'P') and (c2 = 'N') then
  begin
    // PNvnnnd - play note nnn, voice v, duration d

  end;

end;
(******************************************************************************)
procedure TestSID;
begin
  SetWaveForm(0, icWaveTriangle);

  SetPulseWidth(0, 1024);

  SetAtkDcy(0, $15);
  SetStnRls(0, $44);

  while true do
  begin
    PlayNote(0, 4387);
    Delay_ms(200);
    StopNote(0);
    Delay_ms(200);
    
    PlayNote(0, 4927);
    Delay_ms(200);
    StopNote(0);
    Delay_ms(200);

    PlayNote(0, 5530);
    Delay_ms(200);
    StopNote(0);
    Delay_ms(200);

    PlayNote(0, 5859);
    Delay_ms(200);
    StopNote(0);
    Delay_ms(200);

    PlayNote(0, 6577);
    Delay_ms(200);
    StopNote(0);
    Delay_ms(200);

    PlayNote(0, 7382);
    Delay_ms(200);
    StopNote(0);
    Delay_ms(200);

    PlayNote(0, 8286);
    Delay_ms(200);
    StopNote(0);
    Delay_ms(200);

    PlayNote(0, 8779);
    Delay_ms(200);
    StopNote(0);
    Delay_ms(200);

  end;
end;
(******************************************************************************)
var
  cmd: string[8];
  i: byte;
  ch: byte;

begin
  Init;
  
  Delay_ms(50);

  InitSID;
  T0CON.TMR0ON := 1; // Enable Timer0

//  TestSID;

  while true do
  begin
    i := 0;
    repeat
      while PORTB.7 = 0 do
        nop;
      ch := PORTB or %01111111;
      cmd[i] := ch;
      inc(i);
      while PORTB.7 = 1 do
        nop;
    until ch = 0;
    ExecuteCommand(cmd);
  end;
end.
